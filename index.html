<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vehicle Collision Predictor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #container {
            position: relative;
            width: 100%;
            max-width: 640px;
        }
        #video {
            width: 100%;
            height: auto;
            border: 2px solid #333;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #controls {
            margin-top: 20px;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #info {
            margin-top: 20px;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 640px;
        }
        #error {
            color: red;
            margin-top: 10px;
            display: none;
        }
        .detection {
            margin: 10px 0;
            padding: 10px;
            border-left: 4px solid #007bff;
            background-color: #f9f9f9;
        }
        .danger-high { border-left-color: #dc3545; }
        .danger-medium { border-left-color: #ffc107; }
        .danger-low { border-left-color: #28a745; }
    </style>
    <!-- TensorFlow.js and COCO-SSD model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
</head>
<body>
    <h1>Vehicle Collision Predictor</h1>
    <p>Point your phone camera at the road. This app detects vehicles, estimates distances/speeds, and predicts collision risk.</p>
    
    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="controls">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" disabled>Stop Camera</button>
    </div>
    
    <div id="error"></div>
    
    <div id="info">
        <h3>Real-time Analysis</h3>
        <div id="detections"></div>
    </div>

    <script>
        let video = document.getElementById('video');
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let startBtn = document.getElementById('startBtn');
        let stopBtn = document.getElementById('stopBtn');
        let errorDiv = document.getElementById('error');
        let detectionsDiv = document.getElementById('detections');
        
        let model;
        let stream = null;
        let isDetecting = false;
        let vehicleTracks = {};
        let nextId = 0;
        
        const vehicleClasses = ['car', 'truck', 'bus', 'motorcycle'];
        const ASSUMED_FOCAL_LENGTH = 800;
        const AVERAGE_VEHICLE_WIDTH = 1.8;
        const FPS = 30;
        const USER_SPEED = 20; // m/s (72 km/h)
        
        async function initModel() {
            try {
                model = await cocoSsd.load();
                errorDiv.textContent = 'Model loaded successfully';
                errorDiv.style.color = 'green';
                errorDiv.style.display = 'block';
                setTimeout(() => errorDiv.style.display = 'none', 3000);
            } catch (err) {
                showError('Failed to load model: ' + err.message);
            }
        }
        
        async function setupCamera() {
            try {
                // Try preferred constraints (rear camera)
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
            } catch (err) {
                // Fallback to any available camera
                try {
                    stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 }
                        }
                    });
                    showError('Rear camera unavailable, using default camera', false);
                } catch (fallbackErr) {
                    showError('Camera access failed: ' + fallbackErr.message);
                    return false;
                }
            }
            
            try {
                video.srcObject = stream;
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        video.play();
                        resolve();
                    };
                });
                return true;
            } catch (err) {
                showError('Video setup failed: ' + err.message);
                return false;
            }
        }
        
        function showError(message, isWarning = true) {
            errorDiv.textContent = message;
            errorDiv.style.color = isWarning ? 'orange' : 'red';
            errorDiv.style.display = 'block';
        }
        
        function startDetection() {
            isDetecting = true;
            detectFrame();
        }
        
        function stopDetection() {
            isDetecting = false;
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            video.srcObject = null;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            detectionsDiv.innerHTML = '';
            errorDiv.style.display = 'none';
        }
        
        async function detectFrame() {
            if (!isDetecting || !model) return;
            
            try {
                const predictions = await model.detect(video);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                let currentDetections = [];
                
                predictions.forEach(pred => {
                    if (vehicleClasses.includes(pred.class)) {
                        ctx.strokeStyle = '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(pred.bbox[0], pred.bbox[1], pred.bbox[2], pred.bbox[3]);
                        ctx.fillStyle = '#00ff00';
                        ctx.font = '16px Arial';
                        ctx.fillText(`${pred.class} ${Math.round(pred.score * 100)}%`, pred.bbox[0], pred.bbox[1] - 5);
                        
                        const bboxWidth = pred.bbox[2];
                        const estimatedDistance = (AVERAGE_VEHICLE_WIDTH * ASSUMED_FOCAL_LENGTH) / bboxWidth;
                        
                        const centerX = pred.bbox[0] + pred.bbox[2] / 2;
                        const centerY = pred.bbox[1] + pred.bbox[3] / 2;
                        const position = { x: centerX, y: centerY, timestamp: Date.now() };
                        
                        let trackId = findClosestTrack(centerX, centerY);
                        if (trackId === null) {
                            trackId = nextId++;
                            vehicleTracks[trackId] = { positions: [], speeds: [], distances: [] };
                        }
                        
                        const track = vehicleTracks[trackId];
                        track.positions.push(position);
                        track.distances.push(estimatedDistance);
                        
                        if (track.positions.length > 60) {
                            track.positions.shift();
                            track.distances.shift();
                        }
                        
                        if (track.positions.length >= 2) {
                            const prevPos = track.positions[track.positions.length - 2];
                            const dx = centerX - prevPos.x;
                            const dy = centerY - prevPos.y;
                            const pixelSpeed = Math.sqrt(dx*dx + dy*dy) / FPS;
                            const pixelToMeter = 0.01 * (estimatedDistance / 10);
                            const estimatedSpeed = pixelSpeed * pixelToMeter;
                            
                            track.speeds.push(estimatedSpeed);
                            if (track.speeds.length > 60) track.speeds.shift();
                            
                            const avgSpeed = track.speeds.reduce((a, b) => a + b, 0) / track.speeds.length;
                            const relativeSpeed = avgSpeed - USER_SPEED;
                            
                            let ttc = Infinity;
                            let dangerLevel = 'low';
                            if (relativeSpeed > 0 && estimatedDistance > 0) {
                                ttc = estimatedDistance / relativeSpeed;
                                if (ttc < 2) dangerLevel = 'high';
                                else if (ttc < 5) dangerLevel = 'medium';
                            }
                            
                            ctx.fillStyle = dangerLevel === 'high' ? '#ff0000' : dangerLevel === 'medium' ? '#ffff00' : '#00ff00';
                            ctx.fillText(`Speed: ${Math.round(avgSpeed * 3.6)} km/h | Dist: ${Math.round(estimatedDistance)}m | TTC: ${ttc.toFixed(1)}s | Danger: ${dangerLevel}`, pred.bbox[0], pred.bbox[1] + pred.bbox[3] + 20);
                            
                            currentDetections.push({
                                id: trackId,
                                class: pred.class,
                                speed: Math.round(avgSpeed * 3.6),
                                distance: Math.round(estimatedDistance),
                                ttc: ttc.toFixed(1),
                                danger: dangerLevel
                            });
                        } else {
                            currentDetections.push({
                                id: trackId,
                                class: pred.class,
                                speed: 0,
                                distance: Math.round(estimatedDistance),
                                ttc: 'N/A',
                                danger: 'low'
                            });
                        }
                    }
                });
                
                updateDetectionsUI(currentDetections);
                
                Object.keys(vehicleTracks).forEach(id => {
                    if (Date.now() - vehicleTracks[id].positions[vehicleTracks[id].positions.length - 1].timestamp > 2000) {
                        delete vehicleTracks[id];
                    }
                });
                
                requestAnimationFrame(detectFrame);
            } catch (err) {
                showError('Detection error: ' + err.message);
            }
        }
        
        function findClosestTrack(x, y, threshold = 50) {
            let closestId = null;
            let minDist = threshold;
            Object.keys(vehicleTracks).forEach(id => {
                const lastPos = vehicleTracks[id].positions[vehicleTracks[id].positions.length - 1];
                const dist = Math.sqrt((x - lastPos.x)**2 + (y - lastPos.y)**2);
                if (dist < minDist) {
                    minDist = dist;
                    closestId = id;
                }
            });
            return closestId;
        }
        
        function updateDetectionsUI(detections) {
            detectionsDiv.innerHTML = detections.map(det => 
                `<div class="detection danger-${det.danger}">
                    <strong>${det.class.toUpperCase()} #${det.id}</strong><br>
                    Speed: ${det.speed} km/h | Distance: ${det.distance}m | TTC: ${det.ttc}s | Danger: ${det.danger}
                </div>`
            ).join('');
        }
        
        startBtn.addEventListener('click', async () => {
            errorDiv.style.display = 'none';
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('Camera API not supported by this browser');
                return;
            }
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                showError('Camera access requires HTTPS or localhost');
                return;
            }
            startBtn.disabled = true;
            await initModel();
            if (await setupCamera()) {
                stopBtn.disabled = false;
                setTimeout(startDetection, 1000);
            } else {
                startBtn.disabled = false;
            }
        });
        
        stopBtn.addEventListener('click', stopDetection);
    </script>
</body>
</html>
