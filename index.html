<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vehicle Collision Predictor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #container {
            position: relative;
            width: 100%;
            max-width: 640px;
        }
        #video {
            width: 100%;
            height: auto;
            border: 2px solid #333;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #controls {
            margin-top: 20px;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #info {
            margin-top: 20px;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 640px;
        }
        .detection {
            margin: 10px 0;
            padding: 10px;
            border-left: 4px solid #007bff;
            background-color: #f9f9f9;
        }
        .danger-high { border-left-color: #dc3545; }
        .danger-medium { border-left-color: #ffc107; }
        .danger-low { border-left-color: #28a745; }
    </style>
    <!-- TensorFlow.js and COCO-SSD model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
</head>
<body>
    <h1>Vehicle Collision Predictor</h1>
    <p>Point your phone camera at the road. This app detects vehicles, estimates distances/speeds, and predicts collision risk.</p>
    
    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="controls">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" disabled>Stop Camera</button>
    </div>
    
    <div id="info">
        <h3>Real-time Analysis</h3>
        <div id="detections"></div>
    </div>

    <script>
        let video = document.getElementById('video');
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let startBtn = document.getElementById('startBtn');
        let stopBtn = document.getElementById('stopBtn');
        let detectionsDiv = document.getElementById('detections');
        
        let model;
        let isDetecting = false;
        let vehicleTracks = {}; // Simple tracking: {id: {positions: [], speeds: [], distances: []}}
        let nextId = 0;
        
        // Vehicle classes from COCO-SSD
        const vehicleClasses = ['car', 'truck', 'bus', 'motorcycle'];
        
        // Assumptions for estimation (simplified; in reality, calibrate with known distances)
        const ASSUMED_FOCAL_LENGTH = 800; // Pixels (approximate for phone camera)
        const AVERAGE_VEHICLE_WIDTH = 1.8; // meters
        const FPS = 30; // Approximate frame rate
        const USER_SPEED = 20; // m/s (assumed user speed, e.g., 72 km/h; adjust via input if needed)
        
        async function initModel() {
            model = await cocoSsd.load();
            console.log('Model loaded');
        }
        
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: 640, height: 480 }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                };
            } catch (err) {
                alert('Error accessing camera: ' + err.message);
            }
        }
        
        function startDetection() {
            isDetecting = true;
            detectFrame();
        }
        
        function stopDetection() {
            isDetecting = false;
            video.srcObject.getTracks().forEach(track => track.stop());
            startBtn.disabled = false;
            stopBtn.disabled = true;
        }
        
        async function detectFrame() {
            if (!isDetecting || !model) return;
            
            const predictions = await model.detect(video);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let currentDetections = [];
            
            predictions.forEach(pred => {
                if (vehicleClasses.includes(pred.class)) {
                    // Draw bounding box
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(pred.bbox[0], pred.bbox[1], pred.bbox[2], pred.bbox[3]);
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '16px Arial';
                    ctx.fillText(`${pred.class} ${Math.round(pred.score * 100)}%`, pred.bbox[0], pred.bbox[1] - 5);
                    
                    // Estimate distance (using bounding box width and assumed vehicle width)
                    const bboxWidth = pred.bbox[2];
                    const estimatedDistance = (AVERAGE_VEHICLE_WIDTH * ASSUMED_FOCAL_LENGTH) / bboxWidth; // meters
                    
                    // Simple tracking: use bbox center as position
                    const centerX = pred.bbox[0] + pred.bbox[2] / 2;
                    const centerY = pred.bbox[1] + pred.bbox[3] / 2;
                    const position = { x: centerX, y: centerY, timestamp: Date.now() };
                    
                    // Assign or create track
                    let trackId = findClosestTrack(centerX, centerY);
                    if (trackId === null) {
                        trackId = nextId++;
                        vehicleTracks[trackId] = { positions: [], speeds: [], distances: [] };
                    }
                    
                    const track = vehicleTracks[trackId];
                    track.positions.push(position);
                    track.distances.push(estimatedDistance);
                    
                    // Keep last 60 frames (2 seconds at 30fps) for speed calc
                    if (track.positions.length > 60) {
                        track.positions.shift();
                        track.distances.shift();
                    }
                    
                    // Estimate speed (pixels per frame, then convert to m/s)
                    if (track.positions.length >= 2) {
                        const prevPos = track.positions[track.positions.length - 2];
                        const dx = centerX - prevPos.x;
                        const dy = centerY - prevPos.y;
                        const pixelSpeed = Math.sqrt(dx*dx + dy*dy) / FPS; // pixels per second
                        
                        // Rough conversion: assume 1 pixel ~ 0.01m at avg distance (simplified)
                        const pixelToMeter = 0.01 * (estimatedDistance / 10); // Scale by distance
                        const estimatedSpeed = pixelSpeed * pixelToMeter; // m/s
                        
                        track.speeds.push(estimatedSpeed);
                        if (track.speeds.length > 60) track.speeds.shift();
                        
                        // Average speed
                        const avgSpeed = track.speeds.reduce((a, b) => a + b, 0) / track.speeds.length;
                        
                        // Relative speed (assume user moving forward, y decreasing is approaching)
                        const relativeSpeed = avgSpeed - USER_SPEED; // Simplified: positive if approaching
                        
                        // Time to collision (if approaching)
                        let ttc = Infinity;
                        let dangerLevel = 'low';
                        if (relativeSpeed > 0 && estimatedDistance > 0) {
                            ttc = estimatedDistance / relativeSpeed;
                            if (ttc < 2) dangerLevel = 'high';
                            else if (ttc < 5) dangerLevel = 'medium';
                        }
                        
                        // Draw speed and danger
                        ctx.fillStyle = dangerLevel === 'high' ? '#ff0000' : dangerLevel === 'medium' ? '#ffff00' : '#00ff00';
                        ctx.fillText(`Speed: ${Math.round(avgSpeed * 3.6)} km/h | Dist: ${Math.round(estimatedDistance)}m | TTC: ${ttc.toFixed(1)}s | Danger: ${dangerLevel}`, pred.bbox[0], pred.bbox[1] + pred.bbox[3] + 20);
                        
                        currentDetections.push({
                            id: trackId,
                            class: pred.class,
                            speed: Math.round(avgSpeed * 3.6),
                            distance: Math.round(estimatedDistance),
                            ttc: ttc.toFixed(1),
                            danger: dangerLevel
                        });
                    } else {
                        currentDetections.push({
                            id: trackId,
                            class: pred.class,
                            speed: 0,
                            distance: Math.round(estimatedDistance),
                            ttc: 'N/A',
                            danger: 'low'
                        });
                    }
                }
            });
            
            // Update UI with current detections
            updateDetectionsUI(currentDetections);
            
            // Clean up old tracks (if no detection for 2 seconds)
            Object.keys(vehicleTracks).forEach(id => {
                if (Date.now() - vehicleTracks[id].positions[vehicleTracks[id].positions.length - 1].timestamp > 2000) {
                    delete vehicleTracks[id];
                }
            });
            
            requestAnimationFrame(detectFrame);
        }
        
        function findClosestTrack(x, y, threshold = 50) {
            let closestId = null;
            let minDist = threshold;
            Object.keys(vehicleTracks).forEach(id => {
                const lastPos = vehicleTracks[id].positions[vehicleTracks[id].positions.length - 1];
                const dist = Math.sqrt((x - lastPos.x)**2 + (y - lastPos.y)**2);
                if (dist < minDist) {
                    minDist = dist;
                    closestId = id;
                }
            });
            return closestId;
        }
        
        function updateDetectionsUI(detections) {
            detectionsDiv.innerHTML = detections.map(det => 
                `<div class="detection danger-${det.danger}">
                    <strong>${det.class.toUpperCase()} #${det.id}</strong><br>
                    Speed: ${det.speed} km/h | Distance: ${det.distance}m | TTC: ${det.ttc}s | Danger: ${det.danger}
                </div>`
            ).join('');
        }
        
        // Event listeners
        startBtn.addEventListener('click', async () => {
            await initModel();
            await setupCamera();
            startBtn.disabled = true;
            stopBtn.disabled = false;
            setTimeout(startDetection, 1000); // Delay to stabilize video
        });
        
        stopBtn.addEventListener('click', stopDetection);
    </script>
</body>
</html>